<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>surfaceid.surfaceid.util.utils &mdash; LMR-SurfaceID 0.1 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> LMR-SurfaceID
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../util.html">util package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../setup.html">Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model.html">model package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model.html#module-surfaceid.surfaceid.model.model">model.model module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../aligner.html">aligner package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../aligner.html#model-aligner-module">model.aligner module</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">LMR-SurfaceID</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>surfaceid.surfaceid.util.utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for surfaceid.surfaceid.util.utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="c1"># import subprocess</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="c1"># import tempfile</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">cpu_count</span>
<span class="kn">from</span> <span class="nn">Bio.PDB</span> <span class="kn">import</span> <span class="n">PDBParser</span><span class="p">,</span> <span class="n">rotaxis2m</span><span class="p">,</span> <span class="n">PDBIO</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torch_scatter</span>
<span class="kn">import</span> <span class="nn">torch.optim</span> <span class="k">as</span> <span class="nn">optim</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">plyfile</span> <span class="kn">import</span> <span class="n">PlyData</span><span class="p">,</span> <span class="n">PlyElement</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">softmax</span> <span class="k">as</span> <span class="n">scipy_softmax</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>

<span class="kn">from</span> <span class="nn">surfaceid.surfaceid.model.model</span> <span class="kn">import</span> <span class="n">Model</span><span class="p">,</span> <span class="n">clean_tensor</span><span class="p">,</span> <span class="n">Mol</span><span class="p">,</span><span class="n">DNEG</span><span class="p">,</span> <span class="n">DPOS</span><span class="p">,</span> <span class="n">OUTDIR</span>
<span class="kn">from</span> <span class="nn">surfaceid.surfaceid.util.mol</span> <span class="kn">import</span> <span class="n">Mol_with_epitopes</span><span class="p">,</span> <span class="n">Mol_slim</span>
<span class="kn">from</span> <span class="nn">surfaceid.surfaceid.model.aligner</span> <span class="kn">import</span> <span class="n">Aligner1</span><span class="p">,</span><span class="n">get_r</span> 

<span class="c1"># Globals</span>
<span class="n">torch</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">())</span>
<span class="n">RLIM</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">SIG</span> <span class="o">=</span> <span class="mf">0.25</span>
<span class="n">SIG_NORMAL</span> <span class="o">=</span> <span class="mf">3.0</span>
<span class="c1"># Operation</span>
<span class="n">CONTACT</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">DESC</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">SEARCH</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">ALIGN</span> <span class="o">=</span> <span class="kc">True</span>


<div class="viewcode-block" id="gen_descriptors_contact"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.gen_descriptors_contact">[docs]</a><span class="k">def</span> <span class="nf">gen_descriptors_contact</span><span class="p">(</span><span class="n">p1s</span><span class="p">,</span> <span class="n">p2s</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">rho_max</span><span class="p">,</span> <span class="n">outdir</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Obtain Surface ID descriptors for the surface patches at the contact reagions</span>
<span class="sd">        as defined in the &quot;{p1}_contacts.{p2}.npy&quot;. Otherwise it uses entire protein Surface </span>

<span class="sd">    :param p1s: ID for protein 1: Format: PDBID_chain</span>
<span class="sd">    :type p1s: str</span>
<span class="sd">    :param p2s: ID for protein 2: Format: PDBID_chain</span>
<span class="sd">    :type p2s: str</span>
<span class="sd">    :param model:  model class used to obtain descriptors for a given protein   </span>
<span class="sd">    :type model: Model</span>
<span class="sd">    :param device: CPU or GPU</span>
<span class="sd">    :type device: Torch.device</span>
<span class="sd">    :param rho_max: max value for the radial distance from the patch center </span>
<span class="sd">    :type rho_max: float</span>
<span class="sd">    :param outdir: directory where Surface ID descriptors are saved </span>
<span class="sd">    :type outdir: str</span>
<span class="sd">    :param fname: npz file containing descriptors for all proteins</span>
<span class="sd">    :type fname: str</span>
<span class="sd">    :return: pdb,Surface ID descriptors, and patch/vertex indices  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pdbss</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">bs</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">set_grad_enabled</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">p1s</span><span class="p">,</span> <span class="n">p2s</span><span class="p">)):</span>
            <span class="c1"># p1 -&gt; p2</span>
            <span class="c1">#print(i, p1, p2)</span>
            <span class="n">x_</span><span class="p">,</span> <span class="n">rho_</span><span class="p">,</span> <span class="n">theta_</span><span class="p">,</span> <span class="n">mask_</span><span class="p">,</span> <span class="n">idxs0_</span><span class="p">,</span> <span class="n">pdbs_</span> <span class="o">=</span> <span class="n">get_batch</span><span class="p">(</span>
                <span class="n">device</span><span class="p">,</span> <span class="p">[(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)],</span> <span class="n">rho_max</span><span class="p">,</span> <span class="n">contacts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">outdir</span><span class="o">=</span><span class="n">outdir</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_</span><span class="p">),</span> <span class="n">bs</span><span class="p">):</span>
                <span class="n">i2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">i1</span> <span class="o">+</span> <span class="n">bs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_</span><span class="p">))</span>
                <span class="n">o</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x_</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span>
                                   <span class="n">rho_</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span>
                                   <span class="n">theta_</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span>
                                   <span class="n">mask_</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span>
                                   <span class="n">calc_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
            <span class="n">idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idxs0_</span><span class="p">)</span>
            <span class="n">pdbss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pdbs_</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">:</span>
                <span class="c1"># p2 -&gt; p1</span>
                <span class="c1">#print(i, p2, p1)</span>
                <span class="n">x_</span><span class="p">,</span> <span class="n">rho_</span><span class="p">,</span> <span class="n">theta_</span><span class="p">,</span> <span class="n">mask_</span><span class="p">,</span> <span class="n">idxs0_</span><span class="p">,</span> <span class="n">pdbs_</span> <span class="o">=</span> <span class="n">get_batch</span><span class="p">(</span>
                    <span class="n">device</span><span class="p">,</span> <span class="p">[(</span><span class="n">p2</span><span class="p">,</span> <span class="n">p1</span><span class="p">)],</span> <span class="n">rho_max</span><span class="p">,</span> <span class="n">contacts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">outdir</span><span class="o">=</span><span class="n">outdir</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_</span><span class="p">),</span> <span class="n">bs</span><span class="p">):</span>
                    <span class="n">i2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">i1</span> <span class="o">+</span> <span class="n">bs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_</span><span class="p">))</span>
                    <span class="n">o</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x_</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span> <span class="n">rho_</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span> <span class="n">theta_</span><span class="p">[</span>
                                       <span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span> <span class="n">mask_</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span> <span class="n">calc_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
                <span class="n">idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idxs0_</span><span class="p">)</span>
                <span class="n">pdbss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pdbs_</span><span class="p">)</span>
    <span class="n">x_desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
    <span class="n">idxs_desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span>
    <span class="n">pdbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">pdbss</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x_desc</span><span class="p">,</span> <span class="n">pdbs</span><span class="o">=</span><span class="n">pdbs</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="n">idxs_desc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pdbs</span><span class="p">,</span> <span class="n">x_desc</span><span class="p">,</span> <span class="n">idxs_desc</span></div>


<div class="viewcode-block" id="transform_library"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.transform_library">[docs]</a><span class="k">def</span> <span class="nf">transform_library</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">xyz0_mean</span><span class="p">,</span> <span class="n">xyz_mean</span><span class="p">,</span> <span class="n">align_model</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; helper function for patch alignment where the hit patch aligned to the query patch using the align_model</span>

<span class="sd">    :param x: X coordinates for the vertex points on the patch</span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: Y coordinates for the vertex points on the patch</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :param z: Z coordinates for the vertex points on the patch</span>
<span class="sd">    :type z: np.array</span>
<span class="sd">    :param xyz0_mean: center of the query patch</span>
<span class="sd">    :type xyz0_mean: np.array</span>
<span class="sd">    :param xyz_mean: center of the candidate patch</span>
<span class="sd">    :type xyz_mean: np.array</span>
<span class="sd">    :param align_model: the model containing transformation parameters to align candidate patch to the query</span>
<span class="sd">    :type align_model: Class</span>
<span class="sd">    :param idx: Sorted indeces of the loss model</span>
<span class="sd">    :type idx: int</span>
<span class="sd">    :param n: patch normal vector , defaults to None</span>
<span class="sd">    :type n: np.array, optional</span>
<span class="sd">    :return: aligned patch and its normal</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">align_model</span><span class="o">.</span><span class="n">alphas</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(</span>
    <span class="p">),</span> <span class="n">align_model</span><span class="o">.</span><span class="n">betas</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">align_model</span><span class="o">.</span><span class="n">gammas</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="n">Tx</span> <span class="o">=</span> <span class="n">align_model</span><span class="o">.</span><span class="n">Tx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="n">Ty</span> <span class="o">=</span> <span class="n">align_model</span><span class="o">.</span><span class="n">Ty</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="n">Tz</span> <span class="o">=</span> <span class="n">align_model</span><span class="o">.</span><span class="n">Tz</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">Tz</span><span class="p">,</span> <span class="n">xyz0_mean</span><span class="p">,</span> <span class="n">xyz_mean</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Calculate normal match</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">inverse_rotation</span><span class="p">(</span><span class="n">n</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">n</span></div>


<div class="viewcode-block" id="get_score2_helper"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_score2_helper">[docs]</a><span class="k">def</span> <span class="nf">get_score2_helper</span><span class="p">(</span><span class="n">xyz0</span><span class="p">,</span> <span class="n">fs_raw0</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">fs_raw</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">sig_normal</span><span class="o">=</span><span class="n">SIG_NORMAL</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;helper function for computing the alignment score 2.</span>
<span class="sd">this score uses the real space/raw features for the vertexes that are in contact </span>
<span class="sd">(RLIM=1.5\AA). It computes the feature distance for contact verteces and weighs</span>
<span class="sd">it using the softmax of a Gaussian wieghed V-V distance. It also computers the </span>
<span class="sd">dot product of the normals for the contact vertices</span>

<span class="sd">    :param xyz0: coordinates of the query patch</span>
<span class="sd">    :type xyz0: np.array</span>
<span class="sd">    :param fs_raw0: raw features for the query from MaSIF preprocessing </span>
<span class="sd">    :type fs_raw0: np.array</span>
<span class="sd">    :param n0: normal vectors for the query pacth</span>
<span class="sd">    :type n0: np.array</span>
<span class="sd">    :param xyz: coordinates of the candidate patch</span>
<span class="sd">    :type xyz: np.array</span>
<span class="sd">    :param fs_raw: raw features for the candidate from MaSIF preprocessing</span>
<span class="sd">    :type fs_raw: np.array</span>
<span class="sd">    :param n: normal vectors for the candidate pacth</span>
<span class="sd">    :type n: np.array</span>
<span class="sd">    :param sig: the spread for the Gaussian wieghts</span>
<span class="sd">    :type sig: float</span>
<span class="sd">    :param sig_normal: , defaults to SIG_NORMAL</span>
<span class="sd">    :type sig_normal: float, optional</span>
<span class="sd">    :return: alignment nontacts, score (feature), alignment score(normals)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">get_r</span><span class="p">(</span><span class="n">xyz0</span><span class="p">,</span> <span class="n">xyz</span><span class="p">)</span>  <span class="c1"># [N0, N]</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">RLIM</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mf">100.</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">mask</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">mask</span>
    <span class="n">nactive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">scipy_softmax</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">sig</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">f_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">fs_raw0</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">fs_raw</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">score</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">f_matrix</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">nactive</span>
    <span class="n">n_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n0</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">n</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">n_score</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">n_matrix</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">nactive</span>  <span class="c1"># normals are already smoothed</span>
    <span class="k">return</span> <span class="n">nactive</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">n_score</span></div>


<div class="viewcode-block" id="get_score2"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_score2">[docs]</a><span class="k">def</span> <span class="nf">get_score2</span><span class="p">(</span><span class="n">xyz0</span><span class="p">,</span> <span class="n">fs_raw0</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">fs_raw</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; averages the alignment score2 permutating candidate and hit patches</span>

<span class="sd">    :param xyz0: coordinates of the query patch</span>
<span class="sd">    :type xyz0: np.array</span>
<span class="sd">    :param fs_raw0: MaSIF raw feature for the query</span>
<span class="sd">    :type fs_raw0: np.array</span>
<span class="sd">    :param n0: normal vectors on the query</span>
<span class="sd">    :type n0: np.array</span>
<span class="sd">    :param xyz: coordinates of the candidate patch</span>
<span class="sd">    :type xyz: np.array</span>
<span class="sd">    :param fs_raw: MaSIF raw feature for the query</span>
<span class="sd">    :type fs_raw: np.array</span>
<span class="sd">    :param n: normal vectors on the candidate</span>
<span class="sd">    :type n: np.array</span>
<span class="sd">    :param sig: gaussian spread parameter</span>
<span class="sd">    :type sig: float</span>
<span class="sd">    :return: ncontacts, mean scores using features and normals</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nactive1</span><span class="p">,</span> <span class="n">score1</span><span class="p">,</span> <span class="n">n0_score</span> <span class="o">=</span> <span class="n">get_score2_helper</span><span class="p">(</span>
        <span class="n">xyz0</span><span class="p">,</span> <span class="n">fs_raw0</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">fs_raw</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
    <span class="n">nactive2</span><span class="p">,</span> <span class="n">score2</span><span class="p">,</span> <span class="n">n_score</span> <span class="o">=</span> <span class="n">get_score2_helper</span><span class="p">(</span>
        <span class="n">xyz</span><span class="p">,</span> <span class="n">fs_raw</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">xyz0</span><span class="p">,</span> <span class="n">fs_raw0</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
    <span class="n">nactive</span> <span class="o">=</span> <span class="p">(</span><span class="n">nactive1</span> <span class="o">+</span> <span class="n">nactive2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">n_score</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_score</span> <span class="o">+</span> <span class="n">n0_score</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">score</span> <span class="o">=</span> <span class="p">(</span><span class="n">score1</span> <span class="o">+</span> <span class="n">score2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="c1"># # -- using planes</span>
    <span class="c1"># n_score = np.dot(n0_pca, n_pca)</span>

    <span class="k">return</span> <span class="n">nactive</span><span class="p">,</span> <span class="n">n_score</span><span class="p">,</span> <span class="n">score</span></div>

<div class="viewcode-block" id="get_score1"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_score1">[docs]</a><span class="k">def</span> <span class="nf">get_score1</span><span class="p">(</span><span class="n">xyz0</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">npairs</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">get_r</span><span class="p">(</span><span class="n">xyz0</span><span class="p">,</span> <span class="n">xyz</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">npairs</span>

    <span class="k">return</span> <span class="n">loss</span></div>



<div class="viewcode-block" id="get_pca_normal"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_pca_normal">[docs]</a><span class="k">def</span> <span class="nf">get_pca_normal</span><span class="p">(</span><span class="n">xyz</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; computes PCA</span>

<span class="sd">    :param xyz: xyz</span>
<span class="sd">    :type xyz: np.array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">q3</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">components_</span>
    <span class="n">q3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">),</span> <span class="n">q3</span><span class="p">))</span> <span class="o">*</span> <span class="n">q3</span>
    <span class="k">return</span> <span class="n">q3</span></div>


<div class="viewcode-block" id="get_fs"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_fs">[docs]</a><span class="k">def</span> <span class="nf">get_fs</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">pdbs_desc</span><span class="p">,</span> <span class="n">x_desc</span><span class="p">,</span> <span class="n">idxs_desc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;returns the SurfaceID descriptors</span>
<span class="sd">    :param query: the protein id </span>
<span class="sd">    :type query: str</span>
<span class="sd">    :param pdbs_desc: protein ids</span>
<span class="sd">    :type pdbs_desc: np.array</span>
<span class="sd">    :param x_desc: surface id descriptors </span>
<span class="sd">    :type x_desc: np.array</span>
<span class="sd">    :param idxs_desc: surface patch indices</span>
<span class="sd">    :type idxs_desc: np.array</span>
<span class="sd">    :return: surface id descriptors and patch indeces</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iselect</span> <span class="o">=</span> <span class="n">pdbs_desc</span> <span class="o">==</span> <span class="n">query</span>

    <span class="k">return</span> <span class="n">x_desc</span><span class="p">[</span><span class="n">iselect</span><span class="p">],</span> <span class="n">idxs_desc</span><span class="p">[</span><span class="n">iselect</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_xyz_npz"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_xyz_npz">[docs]</a><span class="k">def</span> <span class="nf">get_xyz_npz</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;returns x coordinates of the </span>
<span class="sd">        vertex points on the protein surface </span>

<span class="sd">    :param fname: npz file name</span>
<span class="sd">    :type fname: str</span>
<span class="sd">    :param idxs: vertex id, defaults to None</span>
<span class="sd">    :type idxs: int, optional</span>
<span class="sd">    :return: x coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="n">vs</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">vs</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_normal_npz"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_normal_npz">[docs]</a><span class="k">def</span> <span class="nf">get_normal_npz</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; normal vectors on protein surface</span>

<span class="sd">    :param fname: npz file name </span>
<span class="sd">    :type fname: str</span>
<span class="sd">    :param idxs: vertex id, defaults to None</span>
<span class="sd">    :type idxs: int , optional</span>
<span class="sd">    :return: normal vectors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="n">vs</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;normals&quot;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">vs</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_xyz"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_xyz">[docs]</a><span class="k">def</span> <span class="nf">get_xyz</span><span class="p">(</span><span class="n">plydata</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns the xyz coordinates </span>
<span class="sd">        on portein surface</span>

<span class="sd">    :param plydata: plydata object</span>
<span class="sd">    :type plydata: plydata </span>
<span class="sd">    :param idxs: vertex id , defaults to None</span>
<span class="sd">    :type idxs: int, optional</span>
<span class="sd">    :return: xyz coordinates</span>
<span class="sd">    :rtype: _type_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vs</span> <span class="o">=</span> <span class="n">plydata</span><span class="p">[</span><span class="s2">&quot;vertex&quot;</span><span class="p">]</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">vs</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">vs</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">vs</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">idxs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span></div>


<div class="viewcode-block" id="get_fs_npz"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_fs_npz">[docs]</a><span class="k">def</span> <span class="nf">get_fs_npz</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">idxs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns surface features on </span>
<span class="sd">        protein surface</span>

<span class="sd">    :param fname: npz file name</span>
<span class="sd">    :type fname: str</span>
<span class="sd">    :param idxs: vertex/patch ids</span>
<span class="sd">    :type idxs: np.array</span>
<span class="sd">    :return: MaSIF features</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="s2">&quot;x_initial&quot;</span><span class="p">][</span><span class="n">idxs</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="get_centroid"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_centroid">[docs]</a><span class="k">def</span> <span class="nf">get_centroid</span><span class="p">(</span><span class="n">xyz</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="transform"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.transform">[docs]</a><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">Tz</span><span class="p">,</span> <span class="n">xyz0_mean</span><span class="p">,</span> <span class="n">xyz_mean</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; apply 3D rotation/translation </span>
<span class="sd">    :param x: X coordinates</span>
<span class="sd">    : type x: np.array</span>
<span class="sd">    :param y: Y coordinates</span>
<span class="sd">    : type y: np.array</span>
<span class="sd">    :param z: Z coordinates</span>
<span class="sd">    : type z: np.array</span>
<span class="sd">    :param a: alpha rotation angle</span>
<span class="sd">    : type a: float</span>
<span class="sd">    :param b: beta rotation angle</span>
<span class="sd">    : type b: float</span>
<span class="sd">    :param c: gamma rotation angle</span>
<span class="sd">    : type c: float</span>
<span class="sd">    :param Tx: translation in X direction</span>
<span class="sd">    : type Tx: float</span>
<span class="sd">    :param Ty: translation in y direction</span>
<span class="sd">    : type Ty: float</span>
<span class="sd">    :param Tz: translation in Z direction</span>
<span class="sd">    : type Tz: float</span>
<span class="sd">    :param xyz0_mean: query patch center</span>
<span class="sd">    : type xyz0_mean: float</span>
<span class="sd">    :param xyz_mean: candidate patch center</span>
<span class="sd">    : type xyz_mean: float</span>
<span class="sd">    :return: transformed coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ca</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">cg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">sa</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">sg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">-=</span> <span class="n">xyz_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">-=</span> <span class="n">xyz_mean</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">-=</span> <span class="n">xyz_mean</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">ca</span> <span class="o">*</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">ca</span> <span class="o">*</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">sg</span> <span class="o">-</span> <span class="n">sa</span> <span class="o">*</span> <span class="n">cg</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> \
        <span class="p">(</span><span class="n">ca</span> <span class="o">*</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">cg</span> <span class="o">+</span> <span class="n">sa</span> <span class="o">*</span> <span class="n">sg</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span> <span class="o">+</span> <span class="n">Tx</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">sa</span> <span class="o">*</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">sa</span> <span class="o">*</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">sg</span> <span class="o">+</span> <span class="n">ca</span> <span class="o">*</span> <span class="n">cg</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> \
        <span class="p">(</span><span class="n">sa</span> <span class="o">*</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">cg</span> <span class="o">-</span> <span class="n">ca</span> <span class="o">*</span> <span class="n">sg</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span> <span class="o">+</span> <span class="n">Ty</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">sg</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">cg</span> <span class="o">*</span> <span class="n">z</span> <span class="o">+</span> <span class="n">Tz</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">xyz</span> <span class="o">+=</span> <span class="n">xyz0_mean</span>

    <span class="k">return</span> <span class="n">xyz</span></div>


<div class="viewcode-block" id="inverse_rotation"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.inverse_rotation">[docs]</a><span class="k">def</span> <span class="nf">inverse_rotation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; rotates the coordinates back</span>

<span class="sd">    :param x: X coordinates</span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: Y coordinates</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :param z: Z coordinates</span>
<span class="sd">    :type z: np.array</span>
<span class="sd">    :param a: alpha rotation angle</span>
<span class="sd">    :type a: float</span>
<span class="sd">    :param b: beta rotation angle</span>
<span class="sd">    :type b: float</span>
<span class="sd">    :param g: gamma rotation angle</span>
<span class="sd">    :type g: float</span>
<span class="sd">    :return: transformed oordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ca</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">cg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">sa</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">sg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">ca</span> <span class="o">*</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sa</span> <span class="o">*</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">y</span> <span class="o">-</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">z</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="p">(</span><span class="n">ca</span> <span class="o">*</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">sg</span> <span class="o">-</span> <span class="n">sa</span> <span class="o">*</span> <span class="n">cg</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> \
        <span class="p">(</span><span class="n">sa</span> <span class="o">*</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">sg</span> <span class="o">+</span> <span class="n">ca</span> <span class="o">*</span> <span class="n">cg</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">sg</span> <span class="o">*</span> <span class="n">z</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="p">(</span><span class="n">ca</span> <span class="o">*</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">cg</span> <span class="o">+</span> <span class="n">sa</span> <span class="o">*</span> <span class="n">sg</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> \
        <span class="p">(</span><span class="n">sa</span> <span class="o">*</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">cg</span> <span class="o">-</span> <span class="n">ca</span> <span class="o">*</span> <span class="n">sg</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">cg</span> <span class="o">*</span> <span class="n">z</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">xyz</span></div>


<div class="viewcode-block" id="mean_normal"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.mean_normal">[docs]</a><span class="k">def</span> <span class="nf">mean_normal</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; averages over the </span>
<span class="sd">        patch normal vectors</span>

<span class="sd">    :param n: patch normal vectors</span>
<span class="sd">    :type n: np.array</span>
<span class="sd">    :return: averaged normal vectors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="get_desc_aux"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_desc_aux">[docs]</a><span class="k">def</span> <span class="nf">get_desc_aux</span><span class="p">(</span><span class="n">pdbs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns the indices where a </span>
<span class="sd">given protein id starts and ends</span>
<span class="sd">in Surface ID descriptor file </span>

<span class="sd">:param pdbs: pdb field in the descriptor file</span>
<span class="sd">:type pdbs: np.array</span>
<span class="sd">:return: number of patches corresponding to each  protein in the area of interest, unique protein ids, and the start-end indices for each protein in the descriptor file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pdbs</span><span class="p">))</span>
    <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pdb_pivot</span> <span class="o">=</span> <span class="n">pdbs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pdbs_unique</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pdbs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">pdb_pivot</span> <span class="o">!=</span> <span class="n">pdbs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">pdbs_unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pdb_pivot</span><span class="p">)</span>
            <span class="n">pdb_pivot</span> <span class="o">=</span> <span class="n">pdbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ends</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">starts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">ends</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">pdbs_unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pdb_pivot</span><span class="p">)</span>
    <span class="n">pdbs_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pdbs_unique</span><span class="p">)</span>
    <span class="n">patch_sizes</span> <span class="o">=</span> <span class="n">ends</span><span class="o">-</span><span class="n">starts</span>

    <span class="k">return</span> <span class="n">patch_sizes</span><span class="p">,</span> <span class="n">pdbs_unique</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span></div>


<div class="viewcode-block" id="search"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.search">[docs]</a><span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">o1</span><span class="p">,</span> 
           <span class="n">rho</span><span class="p">,</span> 
           <span class="n">list_indices</span><span class="p">,</span> 
           <span class="n">within</span><span class="p">,</span> 
           <span class="n">library</span><span class="p">,</span>
           <span class="n">library_within</span><span class="p">,</span> 
           <span class="n">pdbs_unique</span><span class="p">,</span> 
           <span class="n">patch_sizes</span><span class="p">,</span>
           <span class="n">pdbs</span><span class="p">,</span> 
           <span class="n">x_desc</span><span class="p">,</span> 
           <span class="n">idxs_desc</span><span class="p">,</span> 
           <span class="n">mini_bs</span><span class="p">,</span> 
           <span class="n">device</span><span class="p">,</span> 
           <span class="n">nmin_pts</span><span class="p">,</span> 
           <span class="n">expand_radius</span><span class="p">,</span> 
           <span class="n">nmin_pts_library</span><span class="p">,</span>
           <span class="n">thres</span><span class="p">,</span> 
           <span class="n">target</span><span class="p">,</span> 
           <span class="n">idxs_contact</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; performs the search for all pairs between the query and candidate</span>
<span class="sd">        first, it computes the descriptor distance between all pair of verticies</span>
<span class="sd">        between  query and candidate. it selects pairs within the descriptor </span>
<span class="sd">        distance thresheold. if number of hits between query and candidate exceeds</span>
<span class="sd">        the threshold arameter, hit grouping is performed to unify vertex hits with</span>
<span class="sd">        their nearest neighbors and form a hit area on each protein surface.</span>

<span class="sd">    :param o1: Surface ID descriptors for the query protein</span>
<span class="sd">    :type o1: torch.tensor</span>
<span class="sd">    :param rho: radial distribution of vertices on a patch from the patch center</span>
<span class="sd">    :type rho: np.array</span>
<span class="sd">    :param list_indices: embedded list containing the vertex ids within each patch</span>
<span class="sd">    :type list_indices: np.array</span>
<span class="sd">    :param within: vertex ids that fall within the neighbor_dist for the query patch</span>
<span class="sd">    :type within: np.array</span>
<span class="sd">    :param library: protein ids in the library</span>
<span class="sd">    :type library: np.array</span>
<span class="sd">    :param library_within: embedded list of vertex ids corresponding to the vertices</span>
<span class="sd">                           within the neighbor_dist of each patch in the candidate protein</span>
<span class="sd">    :type library_within: np.array</span>
<span class="sd">    :param pdbs_unique: unique pdb ids</span>
<span class="sd">    :type pdbs_unique: np.array</span>
<span class="sd">    :param patch_sizes: number of patches for every candidate protein within the area of interest</span>
<span class="sd">    :type patch_sizes: np.array</span>
<span class="sd">    :param pdbs: protein names corresponding to each patch in the library following the Surface ID descriptor</span>
<span class="sd">    :type pdbs: np.array</span>
<span class="sd">    :param x_desc: Surface ID descriptors</span>
<span class="sd">    :type x_desc: torch.tensor</span>
<span class="sd">    :param idxs_desc: patch ids for the corresponding descriptors</span>
<span class="sd">    :type idxs_desc: torch.tensor</span>
<span class="sd">    :param mini_bs: mini batches to perform the search</span>
<span class="sd">    :type mini_bs: torch.tensor</span>
<span class="sd">    :param device: CPU or GPU</span>
<span class="sd">    :type device: str</span>
<span class="sd">    :param nmin_pts: minimum number of hit patches on query for identifying it as a hit  </span>
<span class="sd">    :type nmin_pts: int</span>
<span class="sd">    :param expand_radius: the expansion radius around the hit vertices to define the hit area following the clustering step</span>
<span class="sd">    :type expand_radius: float</span>
<span class="sd">    :param nmin_pts_library: minimum number of hit patches on candidate protein for identifying it as a hit</span>
<span class="sd">    :type nmin_pts_library: int</span>
<span class="sd">    :param thres: threshld used for descriptor distance to identify two patches as similar</span>
<span class="sd">    :type thres: float</span>
<span class="sd">    :param target: protein id for the query </span>
<span class="sd">    :type target: str</span>
<span class="sd">    :param idxs_contact: patch indices for located at the area of contact </span>
<span class="sd">    :type idxs_contact: np.array</span>
<span class="sd">    :return: </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">summary</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">set_grad_enabled</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">lb</span><span class="p">,</span> <span class="n">within_lb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">library</span><span class="p">,</span> <span class="n">library_within</span><span class="p">):</span>
            <span class="n">js</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pdbs_unique</span> <span class="o">==</span> <span class="n">lb</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">js</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># assert False</span>
                <span class="k">continue</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">js</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">patch_sizes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nmin_pts</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="n">o2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">pdbs</span><span class="p">,</span> <span class="n">x_desc</span><span class="p">,</span> <span class="n">idxs_desc</span><span class="p">)</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">o2</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">mini_bs</span><span class="p">):</span>
                <span class="n">i2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">i1</span><span class="o">+</span><span class="n">mini_bs</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>
                <span class="n">o2_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">o2</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
                    <span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i2</span><span class="o">-</span><span class="n">i1</span><span class="p">,</span> <span class="n">o2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">o1</span> <span class="o">-</span> <span class="n">o2_</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">ds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">thres</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">idxs_contact</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># mask out non-contact points</span>
                <span class="n">iselect</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)),</span> <span class="n">idxs_contact</span><span class="p">)</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">iselect</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">hits</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nhits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hits</span><span class="p">)</span>
            <span class="c1"># get lb connectivity / hits</span>
            <span class="k">if</span> <span class="n">nhits</span> <span class="o">&gt;=</span> <span class="n">nmin_pts</span><span class="p">:</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">find_clusters</span><span class="p">(</span>
                    <span class="n">hits</span><span class="p">,</span> <span class="n">within</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">list_indices</span><span class="p">,</span> <span class="n">nmin_pts</span><span class="p">,</span> <span class="n">expand_radius</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">target_nhits</span><span class="p">,</span> <span class="n">target_nexpanded</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                        <span class="c1"># Find the largest library cluster (1st element in the sorted list)</span>
                        <span class="n">hits_lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idxs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="n">hits_lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">hits_lb</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1"># No expanding library epitope</span>
                        <span class="n">idxs_lb</span> <span class="o">=</span> <span class="n">find_clusters</span><span class="p">(</span>
                            <span class="n">hits_lb</span><span class="p">,</span> <span class="n">within_lb</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nmin_pts</span><span class="o">=</span><span class="n">nmin_pts_library</span><span class="p">,</span> <span class="n">expand_radius</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idxs_lb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">lb_nhits</span><span class="p">,</span> <span class="n">lb_nexpanded</span><span class="p">,</span> <span class="n">idxs_lb</span> <span class="o">=</span> <span class="n">idxs_lb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">mean_desc_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">idxs</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">idxs_lb</span><span class="p">])</span>
                        <span class="n">frac_lb_hits</span> <span class="o">=</span> <span class="n">lb_nhits</span> <span class="o">/</span> <span class="n">lb_nexpanded</span>
                        <span class="n">summary</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">target</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">target_nhits</span><span class="p">,</span> <span class="n">target_nexpanded</span><span class="p">,</span>
                                       <span class="n">mean_desc_dist</span><span class="p">,</span> <span class="n">lb_nhits</span><span class="p">,</span> <span class="n">lb_nexpanded</span><span class="p">,</span> <span class="n">frac_lb_hits</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">idxs_lb</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;#Hit identified  </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">lb</span><span class="si">}</span><span class="s2"> :  dt = </span><span class="si">{</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">st</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">summary</span></div>

<div class="viewcode-block" id="find_clusters"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.find_clusters">[docs]</a><span class="k">def</span> <span class="nf">find_clusters</span><span class="p">(</span><span class="n">hits</span><span class="p">,</span> <span class="n">within</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">list_indices</span><span class="p">,</span> <span class="n">nmin_pts</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">expand_radius</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; unites the hit verteces using nearest neighbors within the expansion radius.</span>
<span class="sd">        the clusters that satisfy the cluster size threshold are returned as hit area.</span>

<span class="sd">    :param hits: hit vertex points/patches that satisfy the descriptor distance cutoff </span>
<span class="sd">    :type hits: np.array</span>
<span class="sd">    :param within: </span>
<span class="sd">    :type within: np.array</span>
<span class="sd">    :param rho: radial distances of vertecies wrt patch center</span>
<span class="sd">    :type rho: np.array</span>
<span class="sd">    :param list_indices: embedded list of vertex ids for each patch</span>
<span class="sd">    :type list_indices: list</span>
<span class="sd">    :param nmin_pts: cutoff for cluster size, defaults to 200</span>
<span class="sd">    :type nmin_pts: int, optional</span>
<span class="sd">    :param expand_radius: distance to include the nearest neighbors, defaults to 3.0</span>
<span class="sd">    :type expand_radius: float, optional</span>
<span class="sd">    :return: expanded hit area (vertex points)</span>
<span class="sd">    :rtype: _type_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">taken</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">hits</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">taken</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">taken</span><span class="p">):</span>
        <span class="n">hits_</span> <span class="o">=</span> <span class="n">hits</span><span class="p">[</span><span class="o">~</span><span class="n">taken</span><span class="p">]</span>
        <span class="n">ii_</span> <span class="o">=</span> <span class="n">ii</span><span class="p">[</span><span class="o">~</span><span class="n">taken</span><span class="p">]</span>
        <span class="n">idx_pivot</span> <span class="o">=</span> <span class="n">hits_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="n">within</span><span class="p">[</span><span class="n">idx_pivot</span><span class="p">,</span> <span class="n">hits_</span><span class="p">]</span>
        <span class="c1"># get neighbors</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">hits_</span><span class="p">[</span><span class="n">zs</span><span class="p">]</span>
        <span class="c1"># update taken</span>
        <span class="n">taken</span><span class="p">[</span><span class="n">ii_</span><span class="p">[</span><span class="n">zs</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>

    <span class="c1"># for i in range(0, len(groups), 1):</span>
    <span class="n">ngroups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">group1</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">group1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># print(i, j)</span>
                <span class="n">group2</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="c1"># Any hits?</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">within</span><span class="p">[</span><span class="n">group1</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">group2</span><span class="p">]):</span>  <span class="c1"># within is symmetric</span>
                    <span class="c1"># assert False</span>
                    <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group2</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">groups</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="o">==</span> <span class="n">ngroups</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ngroups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>

    <span class="c1"># eliminate low count groups</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">groups</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">nmin_pts</span><span class="p">]</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="n">groups_expanded</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
        <span class="n">nhits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expand_radius</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
            <span class="n">group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">within</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rho_</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">group</span><span class="p">]</span>
            <span class="n">group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">list_indices</span><span class="p">[</span><span class="n">group</span><span class="p">][(</span>
                <span class="n">rho_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rho_</span> <span class="o">&lt;</span> <span class="n">expand_radius</span><span class="p">)])</span>
        <span class="n">groups_expanded</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nhits</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="n">group</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">groups_expanded</span></div>

<div class="viewcode-block" id="get_batch"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_batch">[docs]</a><span class="k">def</span> <span class="nf">get_batch</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="n">rho_max</span><span class="p">,</span> <span class="n">contacts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">outdir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Mol_with_epitopes</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">contacts</span><span class="p">,</span> <span class="n">outdir</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ps</span><span class="p">]</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s2">&quot;good&quot;</span><span class="p">]</span>
    <span class="n">patches</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">idxs0</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">idxs0</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">idxs0</span><span class="p">,</span> <span class="n">pdbs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">patches</span><span class="p">)</span>
    <span class="n">x_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">rho_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
    <span class="n">theta_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">mask_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">idxs0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">idxs0</span><span class="p">)</span>
    <span class="n">pdbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">pdbs</span><span class="p">)</span>

    <span class="c1"># reduce data</span>
    <span class="n">mask_</span><span class="p">[</span><span class="n">rho_</span> <span class="o">&gt;</span> <span class="n">rho_max</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">mask_</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">npoints</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">m</span><span class="p">[</span><span class="n">npoints</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">npoints</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">npoints</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="n">B</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_</span> <span class="o">=</span> <span class="n">x_</span><span class="p">[:,</span> <span class="p">:</span><span class="n">npoints</span><span class="p">]</span>
    <span class="n">rho_</span> <span class="o">=</span> <span class="n">rho_</span><span class="p">[:,</span> <span class="p">:</span><span class="n">npoints</span><span class="p">]</span>
    <span class="n">theta_</span> <span class="o">=</span> <span class="n">theta_</span><span class="p">[:,</span> <span class="p">:</span><span class="n">npoints</span><span class="p">]</span>
    <span class="n">mask_</span> <span class="o">=</span> <span class="n">mask_</span><span class="p">[:,</span> <span class="p">:</span><span class="n">npoints</span><span class="p">]</span>

    <span class="n">x_</span><span class="p">,</span> <span class="n">rho_</span><span class="p">,</span> <span class="n">theta_</span><span class="p">,</span> <span class="n">mask_</span> <span class="o">=</span> <span class="n">clean_tensor</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">x_</span><span class="p">,</span> <span class="n">rho_</span><span class="p">,</span> <span class="n">theta_</span><span class="p">,</span> <span class="n">mask_</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x_</span><span class="p">,</span> <span class="n">rho_</span><span class="p">,</span> <span class="n">theta_</span><span class="p">,</span> <span class="n">mask_</span><span class="p">,</span> <span class="n">idxs0</span><span class="p">,</span> <span class="n">pdbs</span></div>


<div class="viewcode-block" id="get_whole_molecule_desc"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_whole_molecule_desc">[docs]</a><span class="k">def</span> <span class="nf">get_whole_molecule_desc</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">rho_max</span><span class="p">,</span> <span class="n">bs</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">outdir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns the Surface ID descriptors for the whole entire protein</span>
<span class="sd">    :param target: protein name</span>
<span class="sd">    :type target: str</span>
<span class="sd">    :param model: Surface ID model </span>
<span class="sd">    :type model: Model</span>
<span class="sd">    :param rho_max: max radial cutoff for patch vertices  </span>
<span class="sd">    :type rho_max: float</span>
<span class="sd">    :param bs:batch size, defaults to 256</span>
<span class="sd">    :type bs: int, optional</span>
<span class="sd">    :param device: cpu or gpu, defaults to &quot;cpu&quot;</span>
<span class="sd">    :type device: str, optional</span>
<span class="sd">    :param outdir: directory where descriptors are saved, defaults to None</span>
<span class="sd">    :type outdir: int, optional</span>
<span class="sd">    :return: descriptors, protein name</span>
<span class="sd">    :rtype: _type_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_</span><span class="p">,</span> <span class="n">rho_</span><span class="p">,</span> <span class="n">theta_</span><span class="p">,</span> <span class="n">mask_</span><span class="p">,</span> <span class="n">idxs0_</span><span class="p">,</span> <span class="n">pdbs_</span> <span class="o">=</span> <span class="n">get_batch</span><span class="p">(</span>
        <span class="n">device</span><span class="p">,</span> <span class="p">[(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">)],</span> <span class="n">rho_max</span><span class="p">,</span> <span class="n">contacts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">outdir</span><span class="o">=</span><span class="n">outdir</span><span class="p">)</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_</span><span class="p">),</span> <span class="n">bs</span><span class="p">):</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">i1</span> <span class="o">+</span> <span class="n">bs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_</span><span class="p">))</span>
        <span class="n">o</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x_</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span> <span class="n">rho_</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span> <span class="n">theta_</span><span class="p">[</span>
                           <span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span> <span class="n">mask_</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span> <span class="n">calc_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
    <span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Mol_slim</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">.none&quot;</span><span class="p">,</span> <span class="n">contacts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">outdir</span><span class="o">=</span><span class="n">outdir</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">o</span><span class="p">,</span> <span class="n">p</span></div>




<div class="viewcode-block" id="get_within"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_within">[docs]</a><span class="k">def</span> <span class="nf">get_within</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">list_indices</span><span class="p">,</span> <span class="n">neighbor_dist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns the vertex points within neighbor_dist or patch center</span>

<span class="sd">    :param rho: radial distances of vertex points wrt patch center</span>
<span class="sd">    :type rho: np.array</span>
<span class="sd">    :param list_indices: embedded list of vertices within each patch</span>
<span class="sd">    :type list_indices: list</span>
<span class="sd">    :param neighbor_dist: distance cutoff</span>
<span class="sd">    :type neighbor_dist: float</span>
<span class="sd">    :return: vetex points within the cutoff distance from each patch</span>
<span class="sd">    :rtype: _type_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get inclusion matrix</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
    <span class="n">within</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npts</span><span class="p">,</span> <span class="n">npts</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list_indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="n">neighbor_dist</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">within</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="n">within</span></div>


<div class="viewcode-block" id="get_reordered_subset"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_reordered_subset">[docs]</a><span class="k">def</span> <span class="nf">get_reordered_subset</span><span class="p">(</span><span class="n">idxs</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">list_indices</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns re-ordered subset of points </span>

<span class="sd">    :param idxs:  subset vertices</span>
<span class="sd">    :type idxs: np.array</span>
<span class="sd">    :param rho: radial distances of vertex points wrt patch center</span>
<span class="sd">    :type rho: np.array</span>
<span class="sd">    :param list_indices: embedded list of vertices within each patch</span>
<span class="sd">    :type list_indices: list</span>
<span class="sd">    :return: re-ordered subset of points</span>
<span class="sd">    :rtype: _type_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">idxs_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idxs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">reorder_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">list_indices</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">reorder_map</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">=</span> <span class="n">idxs_new</span>
    <span class="n">rho_subset</span><span class="p">,</span> <span class="n">list_indices_subset</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">idxs</span><span class="p">],</span> <span class="n">reorder_map</span><span class="p">[</span><span class="n">list_indices</span><span class="p">[</span><span class="n">idxs</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">idxs_new</span><span class="p">,</span> <span class="n">rho_subset</span><span class="p">,</span> <span class="n">list_indices_subset</span></div>


<div class="viewcode-block" id="smooth_normals"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.smooth_normals">[docs]</a><span class="k">def</span> <span class="nf">smooth_normals</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">list_indices</span><span class="p">,</span> <span class="n">sig_normal</span><span class="o">=</span><span class="n">SIG_NORMAL</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns the mean of normal vetors for each patch using the </span>
<span class="sd">        vertex points within a cutoff distance of 3*SIG_NORMA. </span>

<span class="sd">    :param n: normal vectors for each vertex point</span>
<span class="sd">    :type n: np.array</span>
<span class="sd">    :param rho: radial distances of vertex points wrt patch center</span>
<span class="sd">    :type rho: np.array</span>
<span class="sd">    :param list_indices: embedded list of vertices within each patch</span>
<span class="sd">    :type list_indices: list</span>
<span class="sd">    :param sig_normal: spread , defaults to SIG_NORMAL</span>
<span class="sd">    :type sig_normal: int, optional</span>
<span class="sd">    :return: mean normal</span>
<span class="sd">    :rtype: _type_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_smoothed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">rlim</span> <span class="o">=</span> <span class="n">SIG_NORMAL</span> <span class="o">*</span> <span class="mi">3</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">list_indices</span><span class="p">,</span> <span class="n">rho</span><span class="p">)):</span>
        <span class="n">iselect</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rlim</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="n">iselect</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">sig_normal</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">n_smoothed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">n</span><span class="p">[</span><span class="n">li</span><span class="p">[</span><span class="n">iselect</span><span class="p">]]</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">iselect</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">n_smoothed</span> <span class="o">=</span> <span class="n">n_smoothed</span> <span class="o">/</span> \
        <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">n_smoothed</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">n_smoothed</span></div>


<div class="viewcode-block" id="compute_aux_vars"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.compute_aux_vars">[docs]</a><span class="k">def</span> <span class="nf">compute_aux_vars</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">OUTDIR</span><span class="p">,</span> <span class="n">expand_radius</span><span class="p">,</span> <span class="n">neighbor_dist</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                     <span class="n">contact_thres1</span><span class="p">,</span> <span class="n">contact_thres2</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; p1, p2 are binding partners. Compute smoothed normals, contact region indices, and a matrix that tells which points are connected</span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTDIR</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s2">_surface.npz&quot;</span><span class="p">))</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">]</span>
    <span class="n">li1</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[</span><span class="s2">&quot;list_indices&quot;</span><span class="p">]</span>
    <span class="n">rho1</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[</span><span class="s2">&quot;normals&quot;</span><span class="p">]</span>
    <span class="n">data2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTDIR</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p2</span><span class="si">}</span><span class="s2">_surface.npz&quot;</span><span class="p">))</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">data2</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">]</span>
    <span class="n">li2</span> <span class="o">=</span> <span class="n">data2</span><span class="p">[</span><span class="s2">&quot;list_indices&quot;</span><span class="p">]</span>
    <span class="n">rho2</span> <span class="o">=</span> <span class="n">data2</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="n">data2</span><span class="p">[</span><span class="s2">&quot;normals&quot;</span><span class="p">]</span>
    <span class="c1"># ---- Create smoothed normals</span>
    <span class="k">if</span> <span class="n">smooth</span><span class="p">:</span>
        <span class="n">fname1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTDIR</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s2">_smoothed_normals.npy&quot;</span><span class="p">)</span>
        <span class="n">n1_smoothed</span> <span class="o">=</span> <span class="n">smooth_normals</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">rho1</span><span class="p">,</span> <span class="n">li1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n1</span> <span class="o">*</span> <span class="n">n1_smoothed</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">n1</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fname1</span><span class="p">,</span> <span class="n">n1_smoothed</span><span class="p">)</span>
        <span class="n">fname2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTDIR</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p2</span><span class="si">}</span><span class="s2">_smoothed_normals.npy&quot;</span><span class="p">)</span>
        <span class="n">n2_smoothed</span> <span class="o">=</span> <span class="n">smooth_normals</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">rho2</span><span class="p">,</span> <span class="n">li2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n2</span> <span class="o">*</span> <span class="n">n2_smoothed</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">n2</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fname2</span><span class="p">,</span> <span class="n">n2_smoothed</span><span class="p">)</span>
    <span class="c1"># ---- calc dist</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;iface&quot;</span><span class="p">:</span>
        <span class="c1"># ---- based on iface</span>
        <span class="n">ii1</span><span class="p">,</span> <span class="n">ii2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">contact_thres1</span><span class="p">)</span>
        <span class="n">if1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data1</span><span class="p">[</span><span class="s2">&quot;iface&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">if2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data2</span><span class="p">[</span><span class="s2">&quot;iface&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># filter by iface</span>
        <span class="n">ii1</span> <span class="o">=</span> <span class="n">ii1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">ii1</span><span class="p">,</span> <span class="n">if1</span><span class="p">)]</span>
        <span class="n">ii2</span> <span class="o">=</span> <span class="n">ii2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">ii2</span><span class="p">,</span> <span class="n">if2</span><span class="p">)]</span>
        <span class="c1"># # ---- based on dist</span>
        <span class="n">ii1_</span><span class="p">,</span> <span class="n">ii2_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">contact_thres2</span><span class="p">)</span>
        <span class="c1"># combine</span>
        <span class="n">ii1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">ii1</span><span class="p">,</span> <span class="n">ii1_</span><span class="p">]))</span>
        <span class="n">ii2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">ii2</span><span class="p">,</span> <span class="n">ii2_</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ii1</span><span class="p">,</span> <span class="n">ii2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">contact_thres1</span><span class="p">)</span>
    <span class="c1"># ---- expand</span>
    <span class="n">rho1_</span> <span class="o">=</span> <span class="n">rho1</span><span class="p">[</span><span class="n">ii1</span><span class="p">]</span>
    <span class="n">ii1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">li1</span><span class="p">[</span><span class="n">ii1</span><span class="p">][(</span><span class="n">rho1_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rho1_</span> <span class="o">&lt;</span> <span class="n">expand_radius</span><span class="p">)])</span>
    <span class="n">rho2_</span> <span class="o">=</span> <span class="n">rho2</span><span class="p">[</span><span class="n">ii2</span><span class="p">]</span>
    <span class="n">ii2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">li2</span><span class="p">[</span><span class="n">ii2</span><span class="p">][(</span><span class="n">rho2_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rho2_</span> <span class="o">&lt;</span> <span class="n">expand_radius</span><span class="p">)])</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;iface&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ii1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">if1</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">if1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ii2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">if2</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii2</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">if2</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="c1"># assert False</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTDIR</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s2">_contacts.</span><span class="si">{</span><span class="n">p2</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">),</span> <span class="n">ii1</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTDIR</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p2</span><span class="si">}</span><span class="s2">_contacts.</span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">),</span> <span class="n">ii2</span><span class="p">)</span>
    <span class="c1"># ---- Compute connectivity matrix</span>
    <span class="c1"># assert False</span>
    <span class="n">ii1</span><span class="p">,</span> <span class="n">rho1</span><span class="p">,</span> <span class="n">li1</span> <span class="o">=</span> <span class="n">get_reordered_subset</span><span class="p">(</span><span class="n">ii1</span><span class="p">,</span> <span class="n">rho1</span><span class="p">,</span> <span class="n">li1</span><span class="p">)</span>
    <span class="n">ii2</span><span class="p">,</span> <span class="n">rho2</span><span class="p">,</span> <span class="n">li2</span> <span class="o">=</span> <span class="n">get_reordered_subset</span><span class="p">(</span><span class="n">ii2</span><span class="p">,</span> <span class="n">rho2</span><span class="p">,</span> <span class="n">li2</span><span class="p">)</span>
    <span class="n">within1</span> <span class="o">=</span> <span class="n">get_within</span><span class="p">(</span><span class="n">rho1</span><span class="p">,</span> <span class="n">li1</span><span class="p">,</span> <span class="n">neighbor_dist</span><span class="p">)</span>
    <span class="n">within2</span> <span class="o">=</span> <span class="n">get_within</span><span class="p">(</span><span class="n">rho2</span><span class="p">,</span> <span class="n">li2</span><span class="p">,</span> <span class="n">neighbor_dist</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTDIR</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s2">_within.</span><span class="si">{</span><span class="n">p2</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">),</span> <span class="n">within1</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTDIR</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p2</span><span class="si">}</span><span class="s2">_within.</span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">),</span> <span class="n">within2</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">None</span></div>


<span class="c1"># ----- OX40 specific funs</span>
<div class="viewcode-block" id="get_cdr_residues"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.get_cdr_residues">[docs]</a><span class="k">def</span> <span class="nf">get_cdr_residues</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">OUTDIR</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;extract the coordinates of CDR residues from the x DataFrame </span>

<span class="sd">    :param x: pd.DataFrame containing the CDRs</span>
<span class="sd">    :type x: pd.DataFrame</span>
<span class="sd">    :param OUTDIR: directory containing the PDB files</span>
<span class="sd">    :type OUTDIR: str</span>
<span class="sd">    :return:  XYZ coordinates of the CDR residues</span>
<span class="sd">    :rtype: _type_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cdr_residues</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">chain</span><span class="p">,</span> <span class="n">cdrs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s2">&quot;L&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">],</span> <span class="p">[(</span><span class="s1">&#39;CDRL1&#39;</span><span class="p">,</span> <span class="s1">&#39;CDRL2&#39;</span><span class="p">,</span> <span class="s1">&#39;CDRL3&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;CDRH1&#39;</span><span class="p">,</span> <span class="s1">&#39;CDRH2&#39;</span><span class="p">,</span> <span class="s1">&#39;CDRH3&#39;</span><span class="p">)]):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cdr</span> <span class="ow">in</span> <span class="n">cdrs</span><span class="p">:</span>
            <span class="n">st</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">cdr</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">e</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">cdr_residues</span><span class="p">[</span><span class="n">chain</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

    <span class="n">pdb</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;Ag&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.pdb&quot;</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTDIR</span><span class="p">,</span> <span class="n">pdb</span><span class="p">)</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">()</span>
    <span class="n">structure</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">pdb</span><span class="p">,</span> <span class="n">fname</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">xs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">():</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">rid</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">get_full_id</span><span class="p">()</span>

        <span class="k">if</span> <span class="s2">&quot;261421&quot;</span> <span class="ow">in</span> <span class="n">pdb</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">chain</span> <span class="o">==</span> <span class="s2">&quot;A&quot;</span><span class="p">:</span>
                <span class="n">chain</span> <span class="o">=</span> <span class="s2">&quot;H&quot;</span>
            <span class="k">elif</span> <span class="n">chain</span> <span class="o">==</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span>
                <span class="n">chain</span> <span class="o">=</span> <span class="s2">&quot;L&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">chain</span> <span class="o">==</span> <span class="s2">&quot;A&quot;</span><span class="p">:</span>
                <span class="n">chain</span> <span class="o">=</span> <span class="s2">&quot;L&quot;</span>
            <span class="k">elif</span> <span class="n">chain</span> <span class="o">==</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span>
                <span class="n">chain</span> <span class="o">=</span> <span class="s2">&quot;H&quot;</span>

        <span class="k">if</span> <span class="n">rid</span> <span class="ow">in</span> <span class="n">cdr_residues</span><span class="p">[</span><span class="n">chain</span><span class="p">]:</span>
            <span class="n">xyzp</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">get_coord</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xyzp</span><span class="p">)</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xs</span></div>


<div class="viewcode-block" id="compute_aux_vars_CDR"><a class="viewcode-back" href="../../../../util.html#surfaceid.surfaceid.util.utils.compute_aux_vars_CDR">[docs]</a><span class="k">def</span> <span class="nf">compute_aux_vars_CDR</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> 
                         <span class="n">OUTDIR</span><span class="p">,</span> 
                         <span class="n">expand_radius</span><span class="p">,</span> 
                         <span class="n">neighbor_dist</span><span class="p">,</span>
                         <span class="n">contact_thres1</span><span class="p">,</span> 
                         <span class="n">contact_thres2</span><span class="p">,</span> 
                         <span class="n">device</span><span class="p">,</span> 
                         <span class="n">x2</span><span class="p">,</span> 
                         <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; idntifies and writes the surface patches at the interace, the mean normal vectors,</span>
<span class="sd">        and vertex points that are within a utoff distance from each patch at the interface</span>

<span class="sd">    :paramp1: protein name</span>
<span class="sd">    :type p2: str</span>
<span class="sd">    :OUTDIR: the directory where the MaSIF surface files are saved</span>
<span class="sd">    :type OUTDIR: str</span>
<span class="sd">    :param expand_radius: cutoff distace to obtain the nearest eighbors</span>
<span class="sd">    :type expand_radius: float</span>
<span class="sd">    :param neighbor_dist: list of vertex points within a patch</span>
<span class="sd">    :type neighbor_dist: list</span>
<span class="sd">    :param contact_thres1: cutoff distance for protein 1 to identify the patches at the area of interest </span>
<span class="sd">    :type contact_thres1: float</span>
<span class="sd">    :param contact_thres2: cutoff distance for protein 2 to identify the patches at the area of interest</span>
<span class="sd">    :type contact_thres2: float</span>
<span class="sd">    :param x2: coordinates of verecies for protein 2</span>
<span class="sd">    :type x2: np.array</span>
<span class="sd">    :return: </span>
<span class="sd">    :rtype: _type_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTDIR</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s2">_surface.npz&quot;</span><span class="p">))</span>

    <span class="n">x1</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">]</span>
    <span class="n">li1</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[</span><span class="s2">&quot;list_indices&quot;</span><span class="p">]</span>
    <span class="n">rho1</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[</span><span class="s2">&quot;normals&quot;</span><span class="p">]</span>
    <span class="c1"># ---- Create smoothed normals</span>
    <span class="k">if</span> <span class="n">smooth</span><span class="p">:</span>
        <span class="n">fname1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTDIR</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s2">_smoothed_normals.npy&quot;</span><span class="p">)</span>
        <span class="n">n1_smoothed</span> <span class="o">=</span> <span class="n">smooth_normals</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">rho1</span><span class="p">,</span> <span class="n">li1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n1</span> <span class="o">*</span> <span class="n">n1_smoothed</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">n1</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fname1</span><span class="p">,</span> <span class="n">n1_smoothed</span><span class="p">)</span>
    <span class="c1"># ---- calc dist</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">ii1</span><span class="p">,</span> <span class="n">ii2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">contact_thres1</span><span class="p">)</span>

    <span class="c1"># ---- expand</span>
    <span class="n">rho1_</span> <span class="o">=</span> <span class="n">rho1</span><span class="p">[</span><span class="n">ii1</span><span class="p">]</span>
    <span class="n">ii1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">li1</span><span class="p">[</span><span class="n">ii1</span><span class="p">][(</span><span class="n">rho1_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rho1_</span> <span class="o">&lt;</span> <span class="n">expand_radius</span><span class="p">)])</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTDIR</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s2">_contacts.</span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">),</span> <span class="n">ii1</span><span class="p">)</span>
    <span class="c1"># ---- Compute connectivity matrix</span>
    <span class="c1"># assert False</span>
    <span class="n">ii1</span><span class="p">,</span> <span class="n">rho1</span><span class="p">,</span> <span class="n">li1</span> <span class="o">=</span> <span class="n">get_reordered_subset</span><span class="p">(</span><span class="n">ii1</span><span class="p">,</span> <span class="n">rho1</span><span class="p">,</span> <span class="n">li1</span><span class="p">)</span>
    <span class="n">within1</span> <span class="o">=</span> <span class="n">get_within</span><span class="p">(</span><span class="n">rho1</span><span class="p">,</span> <span class="n">li1</span><span class="p">,</span> <span class="n">neighbor_dist</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTDIR</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s2">_within.</span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">),</span> <span class="n">within1</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">None</span></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, sansrs.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>